<!DOCTYPE html>
<html>
<meta http-equiv="Cache-Control" content="no-store" />

<head>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
    <script src="presto-client.js" type="text/javascript"></script>
    <script type="text/javascript">
        var headersPushed = false;
        var statementClient = null;
        var getTableDataCalled = false;
        var buffer = [];

        //to store schema information
        var schema = null;

        function init() {
            //init the connector and let Tableau know when we are done
            tableau.initCallback();
        }

        function shutdown() {
            tableau.shutdownCallback();
        }

        /**
            Tableau calls this function to get the metadata.
            This function has to call Tableau with headers before returning.
        */
        function getColumnHeaders() {
           statementClient = new StatementClient(JSON.parse(tableau.connectionData), pushHeadersToTableau, pushDataToTableau, errorHandler);
           //Tableau waits for the headers before calling getTableData()
           while(!headersPushed) {
                statementClient.advance(0);
           }
        }

        function getTableData(lastRecordNumber) {
            getTableDataCalled = true;
            var data = [];

            //we have some buffered data due to advance() calls in getColumnHeaders()
            if(buffer.length > 0) {
                for (var i = 0; i < buffer.length; i++) {
                    //exhaust the buffer first
                    pushDataToTableau(buffer.splice(i, 1)[0], schema, lastRecordNumber);
                    return;
                }
            }

            statementClient.advance(lastRecordNumber);

            if (!statementClient.valid) {
                tableau.dataCallback([], lastRecordNumber);
                return;
            }
        }

        function pushHeadersToTableau(columns) {
            if (columns && !headersPushed) {
                schema = columns;
                var fieldTypes = []
                var fieldNames = []
                for (var i = 0; i < columns.length; i++) {
                    fieldNames.push(columns[i].name);
                    fieldTypes.push(columns[i].type);
                }
                tableau.headersCallback(fieldNames, fieldTypes);
                headersPushed = true;
            }
        }

        function isComplexType(typeName) {
            return (typeName.indexOf('map') === 0) || (typeName.indexOf('array') === 0) || (typeName.indexOf('row') === 0);
        }

        function pushDataToTableau(data, columns, lastRecordNumber) {
            if(data.length > 0) {
                if(!getTableDataCalled) {
                    buffer.push(data);
                    return;
                } else {
                    var tableauData = [];
                    for (var i = 0; i < data.length; i++) {
                        var dataArray = data[i];
                        var row = new Object();
                        for (var j = 0; j < columns.length; j++) {
                            //since Tableau doesn't support complex types convert them to json strings
                            //so at least they get rendered
                            if (isComplexType(columns[j].type)) {
                                row[columns[j].name] = JSON.stringify(dataArray[j]);
                            } else {
                                row[columns[j].name] = dataArray[j];
                            }
                        }
                        tableauData.push(row);
                    }
                    lastRecordNumber = lastRecordNumber + tableauData.length;
                    tableau.dataCallback(tableauData, lastRecordNumber);
                }
            }
        }

        function errorHandler(statusText, errorStr) {
            var message = "Error: [" + statusText + "]: " + errorStr;
            tableau.log(message);
            alert(message);
        }

        function populateCatalogs() {
            var catalogClient = new StatementClient({
                    'catalog': 'hive',
                    'schema': 'default',
                    'query': 'show catalogs'
                },
                function() {},
                function(data, columns) {
                    var catalogSelect = document.getElementById("catalog");
                    for (var i = 0; i < data.length; i++) {
                        var catalog = data[i];
                        var opt = document.createElement("option");
                        opt.textContent = catalog;
                        opt.value = catalog;
                        catalogSelect.appendChild(opt);
                    }
                },
                errorHandler
            );

            while (catalogClient.valid) {
                catalogClient.advance(0);
            }
        }

        function populateSchemas(catalogName) {
            //remove the existing options
            var schemaSelect = document.getElementById("schema");
            for(i = schemaSelect.options.length-1 ; i >= 0 ; i--) {
                schemaSelect.remove(i);
            }

            var schemaClient = new StatementClient({
                    'catalog': catalogName,
                    'schema': 'default',
                    'query': 'show schemas'
                },
                function() {},
                function(data, columns) {
                    for (var i = 0; i < data.length; i++) {
                        var schema = data[i];
                        var opt = document.createElement("option");
                        opt.textContent = schema;
                        opt.value = schema;
                        if (schema == 'default') {
                            opt.setAttribute("selected", "true");
                        }
                        schemaSelect.appendChild(opt);
                    }
                },
                errorHandler
            );
            while (schemaClient.valid) {
                schemaClient.advance(0);
            }
        }

        $(document).ready(function() {
            populateCatalogs();
            //initially load the schemas of the hive catalog
            populateSchemas('hive');

            document.getElementById("catalog").addEventListener('change',
                function() {
                    populateSchemas(this.value);
                }
            , false);

            if(tableau.connectionData) {
                var existingConnectionData = JSON.parse(tableau.connectionData);
                $('textarea#query').val(existingConnectionData.query);
                $('input#user_name').val(existingConnectionData.userName);
            }

            if(tableau.connectionName) {
                $('input#dsname').val(tableau.connectionName);
            }

            $("#inputForm").submit(function() {
                //start with a new client
                statementClient = null;

                //clear global state
                headersPushed = false;
                tableau.connectionData = null;

                var query = $('textarea#query').val();
                var schema = $('select#schema').val();
                var catalog = $('select#catalog').val();
                var userName = $('input#user_name').val();
                var dataSourceName = $('input#dsname').val();

                var connectionData = {
                    'catalog': catalog,
                    'schema': schema,
                    'query': query,
                    'userName': userName
                };

                //set these before validation, because if validation fails
                //the form state is recovered from these variables
                tableau.connectionData = JSON.stringify(connectionData);
                tableau.connectionName = dataSourceName;

                if (!query || query.length == 0 ||
                    !schema || schema.length == 0 ||
                    !catalog || catalog.length == 0 ||
                    !userName || userName.length == 0 ||
                    !dataSourceName || dataSourceName.length == 0) {
                    alert('Please fill in all the fields');
                    return;
                }

                tableau.submit();
            });
        });
    </script>
</head>

<body>
<h2>Presto Tableau Web Connector (Beta)</h2>
<br>
<form id="inputForm" action="">
    User Name:
    <input type="text" id="user_name"><br><br>

    Catalog:
    <select id="catalog"></select><br><br>

    Schema:
    <select id="schema"></select><br><br>

    Data Source Name:
    <input type="text" id="dsname">

    <br><br>Please enter your SQL query:<br>
    <textarea id="query" form="inputForm" rows="20" cols="100"></textarea>

    <br>
    <input type="submit" value="Submit">
</form>
</body>
</html>
